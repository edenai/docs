"""Extract Python code snippets from .mdx documentation files.

Parses all v3/**/*.mdx files, extracts Python code blocks in document order,
and generates importable .py modules with a main() function wrapping the
concatenated snippets.
"""

import re
from pathlib import Path

# Regex to match fenced Python code blocks: ```python [Label]\n...code...\n```
# The closing fence may have leading whitespace (common in the docs).
CODE_BLOCK_RE = re.compile(
    r"^```python(?:[ \t]+\S+)?[ \t]*\n(.*?)^\s*```",
    re.MULTILINE | re.DOTALL,
)

# MDX comment that marks a code block to be skipped by the test suite.
# Place {/* skip-test */} before the ```python fence (or before <CodeGroup>).
_SKIP_COMMENT_RE = re.compile(r"\{/\*\s*skip-test\s*\*/\}")


API_KEY_PATTERNS = [
    (
        re.compile(r'f"Bearer\s+(YOUR_API_KEY|YOUR_EDEN_AI_API_KEY)"'),
        "f\"Bearer {os.environ['EDEN_AI_API_KEY']}\"",
    ),
    (
        re.compile(r'"Bearer\s+(YOUR_API_KEY|YOUR_EDEN_AI_API_KEY)"'),
        "f\"Bearer {os.environ['EDEN_AI_API_KEY']}\"",
    ),
    (
        re.compile(r'"(YOUR_API_KEY|YOUR_EDEN_AI_API_KEY)"'),
        'os.environ["EDEN_AI_API_KEY"]',
    ),
]

# Default production base URL — replaced with env var in generated modules
_DEFAULT_BASE_URL = "https://api.edenai.run"

# Regex matching "https://api.edenai.run" inside a quoted string.
# Captures: (prefix_quote)(url)(rest_of_string_and_quote)
# Works for both plain strings and f-strings.
_BASE_URL_IN_PLAIN_STR_RE = re.compile(
    r"""(?<![f])("https://api\.edenai\.run)"""
)
_BASE_URL_IN_FSTR_RE = re.compile(
    r"""(f"[^"]*?)https://api\.edenai\.run"""
)


DOCS_ROOT = Path(__file__).resolve().parent.parent
GENERATED_DIR = Path(__file__).resolve().parent / "generated"


def extract_python_blocks(mdx_path: Path) -> list[dict]:
    """Extract all Python code blocks from an .mdx file.

    Returns a list of dicts with keys:
        - code: the raw code string
        - line: the 1-based line number where the block starts in the .mdx
    """
    content = mdx_path.read_text()
    blocks = []
    for match in CODE_BLOCK_RE.finditer(content):
        # Skip blocks preceded by {/* skip-test */} within the last 3 lines
        preceding = content[: match.start()]
        recent_lines = preceding.rsplit("\n", 3)[-3:]
        if any(_SKIP_COMMENT_RE.search(line) for line in recent_lines):
            continue
        code = match.group(1)
        # Calculate the line number of the code block start
        line = preceding.count("\n") + 2  # +2: fence line + first code line
        blocks.append({"code": code, "line": line})
    return blocks


def replace_api_keys(code: str) -> str:
    for pattern, replacement in API_KEY_PATTERNS:
        code = pattern.sub(replacement, code)
    return code


def replace_base_url(code: str) -> str:
    """Replace hardcoded https://api.edenai.run with the _EDEN_BASE_URL variable.

    Handles both plain strings and f-strings:
      "https://api.edenai.run/v3/..."  -> f"{_EDEN_BASE_URL}/v3/..."
      f"...https://api.edenai.run..."  -> f"...{_EDEN_BASE_URL}..."
    """
    # First pass: plain strings (not already f-strings)
    code = _BASE_URL_IN_PLAIN_STR_RE.sub(r'f"{_EDEN_BASE_URL}', code)
    # Second pass: already f-strings
    code = _BASE_URL_IN_FSTR_RE.sub(r"\g<1>{_EDEN_BASE_URL}", code)
    return code


def build_module(blocks: list[dict], source_mdx: str) -> tuple[str, bool]:
    """Build a Python module string from extracted code blocks.

    Each block is kept in its original order with comment markers showing
    the source file and line number, mirroring the .mdx structure for
    easy debugging. Imports are kept inline (not hoisted).

    Returns (module_code, has_input).
    """
    if not blocks:
        return "", False

    module_lines = [
        f"# Auto-generated from {source_mdx}",
        "# Do not edit — regenerated by snippet_extractor.py",
        "",
        "import os",
        "",
        f'_EDEN_BASE_URL = os.environ.get("EDEN_AI_BASE_URL", "{_DEFAULT_BASE_URL}")',
        "",
        "",
        "def main():",
    ]

    has_body = False
    has_input = False

    for i, block in enumerate(blocks):
        code = replace_base_url(replace_api_keys(block["code"]))
        line_num = block["line"]

        # Check for input() usage
        if "input(" in code:
            has_input = True

        # Add block header comment
        module_lines.append("")
        module_lines.append(f"    # {'=' * 70}")
        module_lines.append(
            f"    # Block {i + 1}/{len(blocks)} — {source_mdx}:{line_num}"
        )
        module_lines.append(f"    # {'=' * 70}")

        code_text = code.strip("\n")
        if code_text.strip():
            has_body = True
            for line in code_text.split("\n"):
                if line.strip() == "":
                    module_lines.append("")
                else:
                    module_lines.append("    " + line)

    if not has_body:
        module_lines.append("    pass")

    module_lines.append("")
    module_lines.append("")
    module_lines.append('if __name__ == "__main__":')
    module_lines.append("    main()")
    module_lines.append("")

    return "\n".join(module_lines), has_input


def sanitize_filename(mdx_path: Path) -> str:
    """Convert an .mdx file path to a valid Python module name.

    e.g. v3/how-to/universal-ai/text-features.mdx -> v3_how_to_universal_ai_text_features
    """
    relative = mdx_path.relative_to(DOCS_ROOT)
    name = str(relative).replace("/", "_").replace("-", "_").replace(".mdx", "")
    # Ensure it's a valid Python identifier
    name = re.sub(r"[^a-zA-Z0-9_]", "_", name)
    if name[0].isdigit():
        name = "_" + name
    return name


def extract_all() -> list[dict]:
    """Extract snippets from all .mdx files and write generated modules.

    Returns a list of metadata dicts:
        - source_mdx: relative path to the .mdx file
        - module_name: Python module name (importable from tests.generated)
        - generated_path: absolute path to the generated .py file
        - snippet_count: number of Python code blocks found
        - has_input: whether any snippet uses input()
        - blocks: list of {code, line} dicts for individual syntax checking
    """
    GENERATED_DIR.mkdir(parents=True, exist_ok=True)
    init_file = GENERATED_DIR / "__init__.py"
    if not init_file.exists():
        init_file.write_text("")

    mdx_files = sorted(DOCS_ROOT.glob("v3/**/*.mdx"))
    results = []

    for mdx_path in mdx_files:
        blocks = extract_python_blocks(mdx_path)
        if not blocks:
            continue

        source_mdx = str(mdx_path.relative_to(DOCS_ROOT))
        module_name = sanitize_filename(mdx_path)
        module_code, has_input = build_module(blocks, source_mdx)
        generated_path = GENERATED_DIR / f"{module_name}.py"

        generated_path.write_text(module_code)

        results.append(
            {
                "source_mdx": source_mdx,
                "module_name": module_name,
                "generated_path": str(generated_path),
                "snippet_count": len(blocks),
                "has_input": has_input,
                "blocks": blocks,
            }
        )

    return results


def extract_individual_blocks() -> list[dict]:
    """Extract individual Python code blocks for syntax testing.

    Returns a flat list of dicts:
        - source_mdx: relative path to the .mdx file
        - code: raw code string
        - line: starting line number in the .mdx file
        - block_index: 0-based index within the file
    """
    mdx_files = sorted(DOCS_ROOT.glob("v3/**/*.mdx"))
    results = []

    for mdx_path in mdx_files:
        blocks = extract_python_blocks(mdx_path)
        source_mdx = str(mdx_path.relative_to(DOCS_ROOT))

        for i, block in enumerate(blocks):
            results.append(
                {
                    "source_mdx": source_mdx,
                    "code": block["code"],
                    "line": block["line"],
                    "block_index": i,
                }
            )

    return results


if __name__ == "__main__":
    # Run standalone to extract and report
    results = extract_all()
    total_snippets = sum(r["snippet_count"] for r in results)
    print(f"Extracted {total_snippets} Python snippets from {len(results)} .mdx files")
    for r in results:
        flag = " [has input()]" if r["has_input"] else ""
        print(f"  {r['source_mdx']}: {r['snippet_count']} snippets -> {r['module_name']}.py{flag}")
